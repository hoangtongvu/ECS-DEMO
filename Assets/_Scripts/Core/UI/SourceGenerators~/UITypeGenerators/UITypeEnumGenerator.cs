using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Text;
using static UITypeGenerators.Utilities;

namespace UITypeGenerators
{
    [Generator]
    public class UITypeEnumGenerator : IIncrementalGenerator
    {
        private const string uiTypeEnumNamespace = "Core.UI.Identification";
        private const string uiTypeEnumUnderlyingType = "byte";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsTargetNode(syntaxNode),
                    transform: static (context, _) => GetConcreteUIInfo(context));

            context.RegisterSourceOutput(provider.Collect(), Generate);
        }

        private static void Generate(SourceProductionContext context, ImmutableArray<ConcreteUIInfo> concreteUIInfos)
        {
            int length = concreteUIInfos.Length;
            if (length == 0) return;

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();
            sb.AppendLine($"namespace {uiTypeEnumNamespace}");
            sb.AppendLine("{");

            sb.AppendLine($"\tpublic enum UIType : {uiTypeEnumUnderlyingType}");
            sb.AppendLine("\t{");

            for (int i = 0; i < length; i++)
            {
                sb.AppendLine($"\t\t{concreteUIInfos[i].UITypeName} = {i},");
            }

            sb.AppendLine("\t}");

            sb.AppendLine("}");

            context.AddSource($"UIType.g.cs", sb.ToString());
        }

    }

}
