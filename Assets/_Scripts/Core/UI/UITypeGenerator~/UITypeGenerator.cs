using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.IO;

namespace UITypeGenerator
{
    [Generator]
    public class UITypeGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new GenerateUITypeAttributeSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            const string LOG_FILE_PATH = "C:\\Users\\Administrator\\Desktop\\SourceGenErrors.txt";

            try
            {
                if (!(context.SyntaxReceiver is GenerateUITypeAttributeSyntaxReceiver receiver))
                    return;

                int length = receiver.ClassSyntaxes.Count;
                if (length == 0) return;

                string debugContent = "";
                string uiTypeContent = "DefaultUI = 0,\n\t\t";
                string uiTypeEnumNamespace = "Core.UI.Identification";

                for (int i = 0; i < length; i++)
                {
                    var classDeclaration = receiver.ClassSyntaxes[i];
                    string className = classDeclaration.Identifier.ToString();
                    string classNamespace = this.GetNamespace(classDeclaration);
                    var uiTypeName = receiver.UITypeNames[i];

                    this.GeneratePartialOverrideGetUIType(context, className, classNamespace, uiTypeName, uiTypeEnumNamespace);

                    debugContent += $"{classDeclaration.Identifier.Text}-{uiTypeName}";
                    uiTypeContent += $"{uiTypeName} = {i + 1},\n\t\t";

                }

                string uiTypeEnumSourceCode = $@"// <auto-generated />
namespace {uiTypeEnumNamespace}
{{
    public enum UIType : byte
    {{
        {uiTypeContent}
    }}
}}
";

                context.AddSource("UIType.g.cs", uiTypeEnumSourceCode);

                string debugClassSourceCode = $@"
namespace Core.UI.UITypeGenerator
{{
    public static class Debugger
    {{
        public static string DebugContent = ""{debugContent}"";
    }}

}}
";
                context.AddSource("UIGenerator.Debugger.g.cs", debugClassSourceCode);

            }
            catch (Exception e)
            {
                File.AppendAllText(LOG_FILE_PATH, $"Source generator error:\n{e}\n");
            }

        }

        private void GeneratePartialOverrideGetUIType(
            GeneratorExecutionContext context
            , string className
            , string classNamespace
            , string uiTypeName
            , string uiTypeEnumNamespace)
        {
            string uiTypeEnumIdentifier = $"{uiTypeEnumNamespace}.UIType";

            string sourceCode = $@"// <auto-generated />
namespace {classNamespace}
{{
    public partial class {className}
    {{
        public override {uiTypeEnumIdentifier} GetUIType() => {uiTypeEnumIdentifier}.{uiTypeName};
    }}
}}
";

            context.AddSource($"{className}.g.cs", sourceCode);

        }

        private string GetNamespace(SyntaxNode syntaxNode)
        {
            SyntaxNode parent = syntaxNode.Parent;

            while (parent != null)
            {
                if (parent is NamespaceDeclarationSyntax namespaceDeclaration)
                    return namespaceDeclaration.Name.ToString();

                parent = parent.Parent;

            }

            return null;

        }

        private void GetNameAndNamespaceOfGenericArgument(
            SemanticModel semanticModel
            , ExpressionSyntax expressionSyntax
            , out string typeName
            , out string namespaceName)
        {
            ITypeSymbol typeSymbol = semanticModel.GetTypeInfo(expressionSyntax).Type;
            if (typeSymbol != null)
            {
                typeName = typeSymbol.Name;
                namespaceName = typeSymbol.ContainingNamespace?.ToDisplayString() ?? "(NoNamespace)";
                return;
            }

            throw new System.Exception($"Can not resolve {nameof(ITypeSymbol)} for Generic argument");

        }

    }

}