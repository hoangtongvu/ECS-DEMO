using Microsoft.CodeAnalysis;
using static DReactionGenerators.Utilities;

namespace DReactionGenerators
{
    [Generator]
    public class DReactionTagsHandleSystemsGenerator : IIncrementalGenerator
    {
        private const string packageNamespace = "DReaction";
        private const string reactionsHandleSystemGroupName = "ReactionsHandleSystemGroup";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsTargetNode(syntaxNode),
                    transform: static (context, _) => GetReactionComponentsContainerInfo(context));

            context.RegisterSourceOutput(provider, Generate);
        }

        private static void Generate(SourceProductionContext context, ReactionComponentsContainerInfo containerInfo)
        {
            GenerateTagsHandleSystems(context, containerInfo);
        }

        private static void GenerateTagsHandleSystems(SourceProductionContext context, ReactionComponentsContainerInfo containerInfo)
        {
            string startedTagIdentifier = $"{containerInfo.ContainerName}.StartedTag";
            string canUpdateTagIdentifier = $"{containerInfo.ContainerName}.CanUpdateTag";
            string updatingTagIdentifier = $"{containerInfo.ContainerName}.UpdatingTag";
            string endedTagIdentifier = $"{containerInfo.ContainerName}.EndedTag";

            var sourceCode = $@"// <auto-generated />
using Unity.Entities;
using Unity.Burst;
using Unity.Burst.Intrinsics;
using Unity.Collections;
using {containerInfo.ContainerNamespace};

namespace {packageNamespace}
{{
    [UpdateInGroup(typeof({reactionsHandleSystemGroupName}))]
    [BurstCompile]
    public partial struct {containerInfo.ContainerName}_TagsHandleSystem : ISystem
    {{
        private EntityQuery query;
        private ComponentTypeHandle<{startedTagIdentifier}> startedTagTypeHandle;
        private ComponentTypeHandle<{canUpdateTagIdentifier}> canUpdateTagTypeHandle;
        private ComponentTypeHandle<{updatingTagIdentifier}> updatingTagTypeHandle;
        private ComponentTypeHandle<{endedTagIdentifier}> endedTagTypeHandle;

        [BurstCompile]
        public void OnCreate(ref Unity.Entities.SystemState state)
        {{
            var queryBuilder = new EntityQueryBuilder(Allocator.Temp);
            this.query = queryBuilder
                .WithAll<{startedTagIdentifier}>()
                .WithAll<{canUpdateTagIdentifier}>()
                .WithAll<{updatingTagIdentifier}>()
                .WithAll<{endedTagIdentifier}>()
                .WithOptions(EntityQueryOptions.IgnoreComponentEnabledState) 
                .Build(ref state);

            this.startedTagTypeHandle = state.GetComponentTypeHandle<{startedTagIdentifier}>(false);
            this.canUpdateTagTypeHandle = state.GetComponentTypeHandle<{canUpdateTagIdentifier}>(false);
            this.updatingTagTypeHandle = state.GetComponentTypeHandle<{updatingTagIdentifier}>(false);
            this.endedTagTypeHandle = state.GetComponentTypeHandle<{endedTagIdentifier}>(false);

            state.RequireForUpdate(this.query);
        }}

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {{
            this.startedTagTypeHandle.Update(ref state);
            this.canUpdateTagTypeHandle.Update(ref state);
            this.updatingTagTypeHandle.Update(ref state);
            this.endedTagTypeHandle.Update(ref state);

            state.Dependency = new TagsHandleJob
            {{
                StartedTagTypeHandle = this.startedTagTypeHandle,
                CanUpdateTagTypeHandle = this.canUpdateTagTypeHandle,
                UpdatingTagTypeHandle = this.updatingTagTypeHandle,
                EndedTagTypeHandle = this.endedTagTypeHandle,
            }}.ScheduleParallel(this.query, state.Dependency);
        }}

        [BurstCompile]
        public struct TagsHandleJob : IJobChunk
        {{
            public ComponentTypeHandle<{startedTagIdentifier}> StartedTagTypeHandle;
            public ComponentTypeHandle<{canUpdateTagIdentifier}> CanUpdateTagTypeHandle;
            public ComponentTypeHandle<{updatingTagIdentifier}> UpdatingTagTypeHandle;
            public ComponentTypeHandle<{endedTagIdentifier}> EndedTagTypeHandle;

            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {{
                var startedTagEnabledMask_RW = chunk.GetEnabledMask(ref this.StartedTagTypeHandle);
                var canUpdateTagEnabledMask_RO = chunk.GetEnabledMask(ref this.CanUpdateTagTypeHandle);
                var updatingTagEnabledMask_RW = chunk.GetEnabledMask(ref this.UpdatingTagTypeHandle);
                var endedTagEnabledMask_RW = chunk.GetEnabledMask(ref this.EndedTagTypeHandle);

                var enumerator = new ChunkEntityEnumerator(useEnabledMask, chunkEnabledMask, chunk.Count);

                while (enumerator.NextEntityIndex(out var i))
                {{
                    var startedTag = startedTagEnabledMask_RW.GetEnabledRefRW<{startedTagIdentifier}>(i);
                    var canUpdateTag = canUpdateTagEnabledMask_RO.GetEnabledRefRO<{canUpdateTagIdentifier}>(i);
                    var updatingTag = updatingTagEnabledMask_RW.GetEnabledRefRW<{updatingTagIdentifier}>(i);
                    var endedTag = endedTagEnabledMask_RW.GetEnabledRefRW<{endedTagIdentifier}>(i);

                    startedTag.ValueRW = false;
                    endedTag.ValueRW = false;

                    if (canUpdateTag.ValueRO)
                    {{
                        if (!startedTag.ValueRO && !updatingTag.ValueRO)
                        {{
                            //OnReactionStart();
                            startedTag.ValueRW = true;
                            updatingTag.ValueRW = true;
                        }}

                        //OnReactionUpdate();
                    }}
                    else
                    {{
                        if (updatingTag.ValueRO && !endedTag.ValueRO)
                        {{
                            //OnReactionEnd();
                            endedTag.ValueRW = true;
                            updatingTag.ValueRW = false;
                        }}
                    }}

                }}

            }}

        }}

    }}

}}
";

            context.AddSource($"{containerInfo.ContainerNamespace}.{containerInfo.ContainerName}.TagsHandleSystem.g.cs", sourceCode);
        }

    }

}
