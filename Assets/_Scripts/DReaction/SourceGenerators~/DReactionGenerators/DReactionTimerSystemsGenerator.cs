using Microsoft.CodeAnalysis;
using static DReactionGenerators.Utilities;

namespace DReactionGenerators
{
    [Generator]
    public class DReactionTimerSystemsGenerator : IIncrementalGenerator
    {
        private const string packageNamespace = "DReaction";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsTargetNode(syntaxNode),
                    transform: static (context, _) => GetReactionComponentsContainerInfo(context));

            context.RegisterSourceOutput(provider, Generate);
        }

        private static void Generate(SourceProductionContext context, ReactionComponentsContainerInfo containerInfo)
        {
            GenerateTimerSystems(context, containerInfo);
        }

        private static void GenerateTimerSystems(SourceProductionContext context, ReactionComponentsContainerInfo containerInfo)
        {
            string updatingTagIdentifier = $"{containerInfo.ContainerName}.UpdatingTag";
            string endedTagIdentifier = $"{containerInfo.ContainerName}.EndedTag";
            string timerSecondsIdentifier = $"{containerInfo.ContainerName}.TimerSeconds";

            var sourceCode = $@"// <auto-generated />
using Unity.Entities;
using Unity.Burst;
using Unity.Burst.Intrinsics;
using Unity.Collections;
using {containerInfo.ContainerNamespace};
using {packageNamespace}.Utilities.Extensions;

namespace {packageNamespace}
{{
    [UpdateInGroup(typeof(SimulationSystemGroup))]
    [BurstCompile]
    public partial struct {containerInfo.ContainerName}_TimerSystem : ISystem
    {{
        private EntityQuery resetTimerQuery;
        private EntityQuery timerTickQuery;
        private ComponentTypeHandle<{timerSecondsIdentifier}> timerTypeHandle;

        [BurstCompile]
        public void OnCreate(ref Unity.Entities.SystemState state)
        {{
            this.resetTimerQuery = new EntityQueryBuilder(Allocator.Temp)
                .WithAll<{endedTagIdentifier}>()
                .WithAllRW<{timerSecondsIdentifier}>()
                .Build(ref state);

            this.timerTickQuery = new EntityQueryBuilder(Allocator.Temp)
                .WithAll<{updatingTagIdentifier}>()
                .WithAllRW<{timerSecondsIdentifier}>()
                .Build(ref state);

            this.timerTypeHandle = state.GetComponentTypeHandle<{timerSecondsIdentifier}>(false);

            state.RequireForUpdate(this.resetTimerQuery);
            state.RequireForUpdate(this.timerTickQuery);
        }}

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {{
            this.timerTypeHandle.Update(ref state);

            state.Dependency = new ResetTimerJob
            {{
                TimerTypeHandle = this.timerTypeHandle,
            }}.ScheduleParallel(this.resetTimerQuery, state.Dependency);

            state.Dependency = new TimerTickJob
            {{
                DeltaTime = state.WorldUnmanaged.Time.DeltaTime,
                TimerTypeHandle = this.timerTypeHandle,
            }}.ScheduleParallel(this.timerTickQuery, state.Dependency);
        }}

        [BurstCompile]
        public struct ResetTimerJob : IJobChunk
        {{
            public ComponentTypeHandle<{timerSecondsIdentifier}> TimerTypeHandle;

            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {{
                var timerArray = chunk.GetNativeArray(ref this.TimerTypeHandle);

                var enumerator = new ChunkEntityEnumerator(useEnabledMask, chunkEnabledMask, chunk.Count);

                while (enumerator.NextEntityIndex(out var i))
                {{
                    ref var timer = ref timerArray.ElementAt(i);
                    timer.Value = 0;
                }}

            }}

        }}

        [BurstCompile]
        public struct TimerTickJob : IJobChunk
        {{
            [ReadOnly] public float DeltaTime;
            public ComponentTypeHandle<{timerSecondsIdentifier}> TimerTypeHandle;

            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {{
                var timerArray = chunk.GetNativeArray(ref this.TimerTypeHandle);

                var enumerator = new ChunkEntityEnumerator(useEnabledMask, chunkEnabledMask, chunk.Count);

                while (enumerator.NextEntityIndex(out var i))
                {{
                    ref var timer = ref timerArray.ElementAt(i);
                    timer.Value += this.DeltaTime;
                }}

            }}

        }}

    }}

}}
";

            context.AddSource($"{containerInfo.ContainerNamespace}.{containerInfo.ContainerName}.TimerSystem.g.cs", sourceCode);
        }

    }

}
